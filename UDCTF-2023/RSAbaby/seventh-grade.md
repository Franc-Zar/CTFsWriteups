#  RSA School 7th Grade

The challenge provides the following files:

```python
from Crypto.Util.number import *
import sympy.ntheory as nt
import random
p=getPrime(1024)
q=nt.nextprime(p)
for _ in range(random.randint(500,10000)):
    q=nt.nextprime(q)
N=p*q
msg="UDCTF{REDACTED}"
pt=bytes_to_long(msg)
e=65537
ct=pow(pt,e,N)
print(N)
print(e)
print(ct)
```

    17740803753336460891508014077951088945415214329359164945595622460861617151883658129377771074141448545977293824812472806768754107334272113784618671425945265453677763300584120796664192793654787317526905676618168560287204392207536711238413377822113265783504873957094131330620182217422910507867161033695120195691266283498385072573721376398480018719760538723050237163598524153522595496137288270407836138586188296538117138982579560625325815068701431157466298638302885600982291990551448117534677697122276691651611734934147801954625280213769902451417946572231015611006746186167211313556716518863585799128114202130873384852581

    65537

    7617664236008252568996899627946125782926068188323112773389474654757630578865481085502759186904920518615173703165984894164411436709177950136929724052191922739861682189280802963747906815275683543148623167088950096943169566195634558711652670745197446307315888349532981492405588457559228674864147994684328968321710022127803384848143475788457274558988285904875669797926919759123645348144531804252200718312650929926931919262408975771593313266992606751663814830129337536342634243623652919127335934704778878412649409415730419077839365246227059700689395639431013008985996793686430486195007712091309878718060405038405039494286

The above code is vulnerable to [Fermat Attack](https://fermatattack.secvuln.info/) since `p` and `q` are very close prime numbers; i adapted this script i found [here](https://www.geeksforgeeks.org/fermats-factorization-method-for-large-numbers/) to get the job done:

```python
from Crypto.Util.number import long_to_bytes

# Function to find the Floor
# of square root of a number
def sqrtF(x):
	# if x is less than 0
	if x < 0:
		raise ValueError("Negative argument.")
	
	# if x==0 or x==1
	if x == 0 or x == 1:
		return x
	
	y = x // 2
	
	# run a loop
	while y > x // y:
		y = (x // y + y) // 2
	
	return y

# function to find the Ceil
# of square root of a number
def sqrtC(x):
	y = sqrtF(x)

	if x == y * y:
		return y
	else:
		return y + 1

# Fermat factorisation
def FermatFactors(n):
	# if n%2 ==0 then return the factors
	if n % 2 == 0:
		return str(n // 2) + ", 2"
	
	# find the square root
	a = sqrtC(n)
	
	# if the number is a perfect square
	if a * a == n:
		return str(a) + ", " + str(a)
	
	# else perform factorisation
	while True:
		b1 = a * a - n
		b = sqrtF(b1)
		
		if b * b == b1:
			break
		else:
			a += 1
	
	return [a - b, a + b]

# Driver code
if __name__ == "__main__":
    e = 65537
    ct = 7617664236008252568996899627946125782926068188323112773389474654757630578865481085502759186904920518615173703165984894164411436709177950136929724052191922739861682189280802963747906815275683543148623167088950096943169566195634558711652670745197446307315888349532981492405588457559228674864147994684328968321710022127803384848143475788457274558988285904875669797926919759123645348144531804252200718312650929926931919262408975771593313266992606751663814830129337536342634243623652919127335934704778878412649409415730419077839365246227059700689395639431013008985996793686430486195007712091309878718060405038405039494286
    N = 17740803753336460891508014077951088945415214329359164945595622460861617151883658129377771074141448545977293824812472806768754107334272113784618671425945265453677763300584120796664192793654787317526905676618168560287204392207536711238413377822113265783504873957094131330620182217422910507867161033695120195691266283498385072573721376398480018719760538723050237163598524153522595496137288270407836138586188296538117138982579560625325815068701431157466298638302885600982291990551448117534677697122276691651611734934147801954625280213769902451417946572231015611006746186167211313556716518863585799128114202130873384852581

    factors = FermatFactors(N)
    phi = (factors[0] - 1) * (factors[1] - 1)
    
    d = pow(e, -1, phi)
    flag = long_to_bytes(pow(ct, d, N)).decode()
    
    print(flag)     
```

    UDCTF{F3rma7_c4n_sur3_fac70r!}